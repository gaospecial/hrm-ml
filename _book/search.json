[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HRM-ML Paper",
    "section": "",
    "text": "Preface\nThis book contains the supplementary information of the manuscript entitled “Precise prediction of synthetic community structure with high-resolution melting curve and machine learning” authored by Chun-Hui Gao, Jiaqi He, et. al.\n\n\n\n\n\n\n\nNote\n\n\n\nThis is a Quarto book, created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\nTo learn more about Quarto books visit https://quarto.org/docs/books.\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "single-species-modeling.html",
    "href": "single-species-modeling.html",
    "title": "1  Single Species Modeling",
    "section": "",
    "text": "1.1 Global setting\nHere we load packages and define several frequently used variables.\n# load required packages\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(mcmodel)\nlibrary(cowplot)\n\n# default theme\ntheme_set(theme_bw() +\n            theme(legend.key.size = unit(0.4,'cm'),\n                  legend.key.height = unit(.4, 'cm')))\n\n# global setting\nstrain_label = c(\"label_E\", \"label_P\")\nstrain_name = c(\"EC\",\"PP\")\nstrain_color = c(\"red3\", \"purple3\")\n\n# well position\nec_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(1:3, each = 16))\npp_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(4:6, each = 16))\ngradient_matrix_well = paste0(rep(LETTERS[1:16],times = 16), rep(7:22,each = 16))\nstrain_single_well = list(EC = ec_single_well, PP = pp_single_well)\n\n# set seed\nset.seed(0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#data-process",
    "href": "single-species-modeling.html#data-process",
    "title": "1  Single Species Modeling",
    "section": "1.2 Data process",
    "text": "1.2 Data process\nWe use one experiment to start the story.\nThe experiment of melting curve analysis (and RT-PCR) was performed with a QuantStudio Software supported machine. Therefore, the results file used here is the plain text output of full results of the QuantStudio software (V1.5). In mcmodel package, it has the read_quantstudio() function to read in the data and transform the full record to a QuantStudioRaw class object.\n\n# read qPCR run results\nraw_file = xfun::magic_path(\"cycle30-experiment1.txt\")\nquantstudio_raw = read_quantstudio(raw_file)\nquantstudio_raw\n\nAn object of class 'QuantStudioRaw':\n  Slots: [Sample Setup], [Raw Data], [Amplification Data],\n         [Multicomponent Data], [Results], [Reagent Information], [Melt\n         Curve Raw Data], Meta;\n\n\nThe plate setting used in melting curve analysis is provided in a csv file. Original value for each column is the times of two-fold dilution, and we transform them into DNA quantity as related to the original concentration (assumed to be 1). Note: a label value of 16 means not contain this species.\n\n# read plate setting\nplate_file = xfun::magic_path(\"modeling-plate-labels.csv\")\nplate = read.csv(plate_file)\nplate2 = plate |&gt; \n  drop_na() |&gt; \n  mutate(label_E = ifelse(label_E == 0, 1, ifelse(label_E == 16, 0, 1/2^label_E)),\n         label_P = ifelse(label_P == 0, 1, ifelse(label_P == 16, 0, 1/2^label_P)))",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#well-concentration",
    "href": "single-species-modeling.html#well-concentration",
    "title": "1  Single Species Modeling",
    "section": "1.3 Well concentration",
    "text": "1.3 Well concentration\nA 384-well PCR plate was divided into two parts. 1) the dilution of single species DNA template of E. coli (Figure 1.1a) and P. putida (Figure 1.1b), 2) the gradient matrix of two-species DNA mixtures (Figure 1.1c).\n\np_concentration = lapply(seq_along(strain_label), function(i){\n  plate2  |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    plot_384_single_concentration(strain_label[[i]], well_size = 1.5) + \n    scale_color_gradient(high = strain_color[[i]], \n                         low = \"white\",\n                         trans = \"log2\",\n                         na.value = \"grey90\") +\n    coord_equal() +\n    theme(legend.position = 'none')\n})\n\nplate3 = plate2 |&gt; \n  dplyr::filter(well_position %in% gradient_matrix_well)\np_matrix = plot_384_community_structure(plate3) + \n  scale_fill_manual(values = c(\"red3\",\"purple3\")) +\n  coord_equal() +\n  theme(legend.position = 'none')\n\nplot_grid(p_concentration[[1]], p_concentration[[2]], p_matrix, \n          ncol = 2, labels = 'auto')\n\n\n\n\n\n\n\nFigure 1.1: Settings of a 384-well PCR plate.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#amplification-plot",
    "href": "single-species-modeling.html#amplification-plot",
    "title": "1  Single Species Modeling",
    "section": "1.4 Amplification plot",
    "text": "1.4 Amplification plot\n\n# plot amplification curve\nqs_amplification = get_quantstudio_amplication(quantstudio_raw)\n\n\np_amp = lapply(seq_along(strain_label), function(i){\n  df = qs_amplification  |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    left_join(plate2)\n  \n  ggplot(df, aes(cycle, delta_rn, group = well_position)) +\n    geom_line(aes(color = .data[[strain_label[[i]]]])) +\n    geom_hline(yintercept = 0.124, linetype = 'dashed', color = 'grey') +\n    geom_text(x = -Inf, y = 0.124, label = 'Ct threshold', \n              hjust = -.25, vjust = -0.5, color = 'grey') +\n    scale_color_gradient(\n      high = strain_color[[i]], low = \"white\", trans = 'log2', \n      labels = trans_format(\"log2\", label_number_auto()), \n      breaks = 2^c(0, -5, -10, -15)\n    ) +\n    labs(color = expression(log[2]*Q), y = 'fluorescence') +\n    theme(legend.position = \"inside\",\n          legend.position.inside = c(0.38,0.62))\n})\n\nJoining with `by = join_by(well_position)`\nJoining with `by = join_by(well_position)`\n\nplot_grid(plotlist = p_amp, labels = \"auto\")\n\n\n\n\n\n\n\nFigure 1.2: Amplification curves of singe species DNAs",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#ct-model-of-single-species",
    "href": "single-species-modeling.html#ct-model-of-single-species",
    "title": "1  Single Species Modeling",
    "section": "1.5 Ct model of single species",
    "text": "1.5 Ct model of single species\n\n# check ct calling results\nqs_results = get_quantstudio_result(quantstudio_raw) |&gt; \n  dplyr::select(well_position, ct) |&gt; \n  dplyr::mutate(ct = as.numeric(ct)) |&gt; \n  left_join(plate2) |&gt; \n  pivot_longer(cols = starts_with(\"label_\"), \n               names_to = \"strain\", \n               values_to = \"quantity\")  |&gt; \n  dplyr::filter(quantity != 0, !is.na(ct))\n\nWarning: There was 1 warning in `dplyr::mutate()`.\nℹ In argument: `ct = as.numeric(ct)`.\nCaused by warning:\n! NAs introduced by coercion\n\n\nJoining with `by = join_by(well_position)`\n\nmono_ct = qs_results  |&gt; \n  dplyr::filter(well_position %in% unlist(strain_single_well))\nmono_ct\n\n# A tibble: 90 × 4\n   well_position    ct strain  quantity\n   &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;\n 1 A1             15.4 label_E      1  \n 2 A2             13.9 label_E      1  \n 3 A3             15.2 label_E      1  \n 4 A4             18.3 label_P      1  \n 5 A5             20.1 label_P      1  \n 6 A6             19.0 label_P      1  \n 7 B1             14.5 label_E      0.5\n 8 B2             14.3 label_E      0.5\n 9 B3             14.8 label_E      0.5\n10 B4             15.2 label_P      0.5\n# ℹ 80 more rows\n\n\n\np_ct = lapply(seq_along(strain_label), function(i){\n  qs_results |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    ggplot(aes(ct, log2(quantity))) +\n    geom_smooth(method = 'lm', color = strain_color[[i]]) +\n    geom_point(shape = 21, color = strain_color[[i]]) +\n    labs(y = expression(log[2]*Q), x = 'Ct')\n})\n\nplot_grid(plotlist = p_ct, labels = \"auto\")\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigure 1.3: Correlation of Ct values and log2-transformed DNA quantities",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#melting-curve-gradient",
    "href": "single-species-modeling.html#melting-curve-gradient",
    "title": "1  Single Species Modeling",
    "section": "1.6 Melting curve gradient",
    "text": "1.6 Melting curve gradient\n\nmc = quantstudio2mc(quantstudio_raw, plate = plate2, primer = \"V4\")\nmc = filterData(mc, from = 80, to = 90) |&gt; \n  transformData(step = 0.1)\n\n\nplot_mc_single = function(mc, label_color, vline_color){\n  # get tm value (median)\n  tm = mc_get_tm(mc, npeaks = 1) |&gt; pull(peak_position) |&gt; median()\n  \n  df = mc2tbl(mc) |&gt; \n    select(-date, -primer) |&gt; \n    summarize(derivative = median(derivative), \n              .by = all_of(c(\"temperature\", label_color)))\n  \n  # plot mc\n  ggplot(df, \n         aes(temperature, derivative, \n             color = .data[[label_color]], \n             group = .data[[label_color]])) + \n    geom_line() + \n    geom_vline(aes(xintercept = I(tm)), \n               linetype = 'dashed', \n               color = vline_color) +\n    geom_text(x = tm, y = Inf, hjust = -0.1, vjust = 2, \n              label = paste0(\"Tm = \", tm, \"°C\"), \n              color = vline_color)  +\n    scale_x_continuous(breaks = c(80, 85, 90)) +\n    labs(x = \"temperature (°C)\", \n         y = \"fluorescence\", \n         color = expression(log[2]*Q)) +\n    theme(legend.position = \"inside\",\n          legend.position.inside = c(0.75,0.5))\n}\n\np_mc = lapply(seq_along(strain_label), function(i){\n  filterData(mc, well_position = strain_single_well[[i]]) |&gt; \n    plot_mc_single(strain_label[[i]], strain_color[[i]]) +\n    scale_color_gradient(\n      high = strain_color[[i]], \n      low = \"white\", \n      trans = 'log2', \n      labels = trans_format(\"log2\", label_number_auto()), \n      breaks = 2^c(0, -5, -10, -15)\n    ) \n})\n\nplot_grid(plotlist = p_mc, ncol = 2, labels = \"auto\")\n\n\n\n\n\n\n\nFigure 1.4: Melting curves of single species DNAs",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#peak-calling",
    "href": "single-species-modeling.html#peak-calling",
    "title": "1  Single Species Modeling",
    "section": "1.7 Peak calling",
    "text": "1.7 Peak calling\nDetect peak and get peak features.\n\nmono_mc = lapply(seq_along(strain_label), function(i){\n  x = filterData(mc, well_position = strain_single_well[[i]]) |&gt; \n    transformData(step = 0.1)\n  df = mc2tbl(x) |&gt; \n    select(-date, -primer) |&gt; \n    nest(data = c(temperature, derivative)) |&gt; \n    pivot_longer(cols = starts_with(\"label_\"), \n                 names_to = \"strain\", \n                 values_to = \"quantity\") \n  peaks = lapply(df$data, \n                 mcmodel:::detect_tm, \n                 zero = \"+\", \n                 npeaks = 1, \n                 sortstr = TRUE, \n                 threshold = 0) |&gt; \n    bind_rows()\n  bind_cols(df, peaks)\n}) |&gt; \n  bind_rows() |&gt; \n  dplyr::filter(quantity != 0)\n\nmono_mc$peak_area = sapply(1:nrow(mono_mc), function(i){\n  d = mono_mc$data[[i]] |&gt; \n    filter(temperature &gt;= mono_mc$peak_start[[i]], \n           temperature &lt;= mono_mc$peak_end[[i]])\n  pracma::trapz(d$temperature, d$derivative)\n})\n\npeak_cols = paste('peak', \n                  c('height','area','start','position','end'), \n                  sep = \"_\")\nmono_mc = mono_mc |&gt; \n  dplyr::select(well_position, strain, quantity, matches(peak_cols))\n\nmono_mc\n\n# A tibble: 96 × 8\n   well_position strain  quantity peak_height peak_area peak_start peak_position\n   &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;\n 1 A1            label_E    1           0.644     0.740       82.1          84.3\n 2 A2            label_E    1           0.801     0.938       82.3          84.3\n 3 A3            label_E    1           0.673     0.791       82.2          84.3\n 4 B1            label_E    0.5         0.761     0.898       82.4          84.4\n 5 B2            label_E    0.5         0.882     1.06        83            84.8\n 6 B3            label_E    0.5         0.751     0.905       82.1          84.3\n 7 C1            label_E    0.25        0.771     0.946       82            84.3\n 8 C2            label_E    0.25        0.844     1.06        82.1          84.4\n 9 C3            label_E    0.25        0.737     0.871       82.4          84.3\n10 D1            label_E    0.125       0.691     0.838       82.2          84.3\n# ℹ 86 more rows\n# ℹ 1 more variable: peak_end &lt;dbl&gt;\n\n\nCorrelations of DNA quantity to peak features.\n\nplots = lapply(peak_cols, function(x){\n  ggplot(mono_mc, aes(log2(quantity), .data[[x]], color = .data$strain)) + \n    geom_point(size = 0.2) +\n    geom_smooth(method = MASS::rlm) +\n    labs(x = expression(log[2]*Q), \n         y = sub(pattern = \"_\", replacement = \" \", x)) +\n    scale_color_manual(values = strain_color) +\n    theme(legend.position = \"none\")\n})\n\nplot_grid(plotlist = plots, align = 'hv', ncol = 3, labels = \"auto\")\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigure 1.5: Correlations of DNA quantity and peak-associated features extracted from single species melting curves.\n\n\n\n\n\nlibrary(corrplot)\n\ncorrplot 0.92 loaded\n\nmono_mc_vars = mono_mc |&gt; \n  dplyr::mutate(log2Q = log2(quantity)) |&gt; \n  dplyr::select(well_position, log2Q, matches(peak_cols)) |&gt; \n  dplyr::rename(`$log[2]*Q` = log2Q) |&gt; \n  dplyr::rename_with(.fn = function(x) sub(\"_\", \" \", x), \n                     .cols = matches(peak_cols))\n\ncols = c('Reds','Purples')\np_mc_corrplot = lapply(seq_along(strain_label), function(i){\n  vars = mono_mc_vars  |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    dplyr::select(-well_position)\n  M = cor(vars)\n  T = cor.mtest(vars, conf.level = 0.95)\n  corrplot::corrplot(M, \n                     diag = FALSE, addCoef.col = 'grey80',\n                     col = COL1(cols[[i]]),\n                     tl.srt = 30,\n                     tl.col = strain_color[[i]],\n                     p.mat = T$p)\n})\n\n\n\n\n\n\n\n\n\n\n\n(a) E. coli\n\n\n\n\n\n\n\n\n\n\n\n(b) P. putida\n\n\n\n\n\n\n\nFigure 1.6: Correlations of DNA quantity and peak-associated features extracted from single species melting curves.\n\n\n\n\np_peak_height = lapply(seq_along(strain_label), function(i){\n  mono_mc |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    ggplot(aes(peak_height, log2(quantity))) +\n    geom_smooth(method = 'lm', color = strain_color[[i]]) +\n    geom_point(shape = 21, color = strain_color[[i]]) +\n    labs(x = 'peak height',\n         y = expression(log[2]*Q))\n})\n\nplot_grid(plotlist = p_peak_height, ncol = 2, labels = \"auto\")\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigure 1.7: Correlation of log2-transformed DNA quantities and peak heights\n\n\n\n\n\n\np_peak_area = lapply(seq_along(strain_label), function(i){\n  mono_mc |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    ggplot(aes(peak_area, log2(quantity))) +\n    geom_smooth(method = 'lm', color = strain_color[[i]]) +\n    geom_point(shape = 21, color = strain_color[[i]]) +\n    labs(x = 'peak area', y = expression(log[2]*Q))\n})\n\nplot_grid(plotlist = p_peak_area, ncol = 2, labels = \"auto\")\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigure 1.8: Correlation of log2-transformed DNA quantities and peak areas",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#comparision-of-ct-and-mc-modelling",
    "href": "single-species-modeling.html#comparision-of-ct-and-mc-modelling",
    "title": "1  Single Species Modeling",
    "section": "1.8 Comparision of Ct and MC modelling",
    "text": "1.8 Comparision of Ct and MC modelling\n\nqs_single_results = qs_results |&gt; \n  dplyr::filter(well_position %in% unlist(strain_single_well))\nqs_single_results\n\n# A tibble: 90 × 4\n   well_position    ct strain  quantity\n   &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;\n 1 A1             15.4 label_E      1  \n 2 A2             13.9 label_E      1  \n 3 A3             15.2 label_E      1  \n 4 A4             18.3 label_P      1  \n 5 A5             20.1 label_P      1  \n 6 A6             19.0 label_P      1  \n 7 B1             14.5 label_E      0.5\n 8 B2             14.3 label_E      0.5\n 9 B3             14.8 label_E      0.5\n10 B4             15.2 label_P      0.5\n# ℹ 80 more rows\n\n\n\nmodel_metric = function(formula, data, ...){\n  model = lm(formula, data)\n  summary = summary(model)\n  quosures = enquos(...)\n  tibble(data = deparse(substitute(data)), \n         formula = paste(as.character(formula), collapse = \" \"), \n         metric = c(\"r_squared\", \"adj_r_squared\"),\n         value = c(summary$r.squared, summary$adj.r.squared)) |&gt; \n    dplyr::mutate(!!!quosures, .before = 1)\n}\n\n\nplot_model_metric = function(model, test_data, color){\n  predictions = augment(model, newdata = test_data)\n  metrics = metric_set(rmse, rsq, mae)\n  model_metrics = metrics(predictions, \n                          truth = 'log2quantity', \n                          estimate = .fitted)\n  annotation = paste(model_metrics[['.metric']], \n                     round(model_metrics[['.estimate']], digits = 2), \n                     sep = \": \", \n                     collapse = \"\\n\")\n  ggplot(predictions, aes(`log2quantity`, `.fitted`, color = I(color))) +\n    geom_point(shape = 21) +\n    geom_abline(slope = 1, linetype = 'dashed', color = color) +\n    annotate(\"text\", x = -Inf, y = Inf, label = annotation, \n             color = I(color),\n             hjust = -0.1, vjust = 1.1) +\n    coord_equal() +\n    xlim(c(-16,0)) + ylim(c(-16, 0)) +\n    labs(x = expression(log[2]*Q[true]), y = expression(log[2]*Q[pred]))\n}\n\np_model_ct = lapply(seq_along(strain_label), function(i){\n  data = mono_ct |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    mutate(log2quantity = log2(quantity))\n  data_split_single = initial_split(data)\n  data_train_single = training(data_split_single)\n  data_test_single = testing(data_split_single)\n  model = lm(log2quantity ~ ct, data_train_single)\n  p = plot_model_metric(model, data_test_single, \n                        strain_color[[i]]) + labs(subtitle = 'Ct model')\n  return(p)\n})\n\np_model_mc = lapply(seq_along(strain_label), function(i){\n  data = mono_mc |&gt; \n    dplyr::filter(well_position %in% strain_single_well[[i]]) |&gt; \n    mutate(log2quantity = log2(quantity))\n  data_split_single = initial_split(data)\n  data_train_single = training(data_split_single)\n  data_test_single = testing(data_split_single)\n  model = lm(log2quantity ~ peak_area + peak_height + peak_start + peak_end, \n             data_train_single)\n  plot_model_metric(model, data_test_single, strain_color[[i]]) + \n    labs(subtitle = 'MC model')\n})\n\nplot_grid(plotlist = c(p_model_ct, p_model_mc), align = 'hv', labels = \"auto\")\n\n\n\n\n\n\n\nFigure 1.9: Comparison of Ct and Mc linear modelling",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "single-species-modeling.html#combined-results",
    "href": "single-species-modeling.html#combined-results",
    "title": "1  Single Species Modeling",
    "section": "1.9 Combined Results",
    "text": "1.9 Combined Results\n\nplot_grid(plotlist = c(p_amp, p_mc, p_model_ct, p_model_mc), \n          align = 'hv', \n          ncol = 4, nrow = 2, labels = 'auto')\n\nggsave(\"figures/figure1.jpg\")\n\nSaving 9.5 x 5.87 in image\n\n\n\n\n\n\n\n\nFigure 1.10: Linear modelling and prediction of single species abundance with threshold cycle (Ct) and melting curve features in a two-species SynComs (red, E. coli. purple, P. putida. Same below).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Single Species Modeling</span>"
    ]
  },
  {
    "objectID": "data-preprocess.html",
    "href": "data-preprocess.html",
    "title": "2  Data preprocess",
    "section": "",
    "text": "2.1 Files\nThe plate setting used in melting curve analysis is provided in a csv file. Original value for each column is the times of two-fold dilution, and we transform them into DNA quantity as related to the original concentration (assumed to be 1).\nNote: a label value of 16 means not contain this species.\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# experimental results\nfiles = list.files(\"data-raw/modeling-qPCR\", pattern = \".txt\", full.names = TRUE)\n\n# plate setting - layout\nplate = read.csv(xfun::magic_path(\"modeling-plate-labels.csv\")) |&gt; \n  mutate(label_E = ifelse(label_E == 0, 1, ifelse(label_E == 16, 0, 1/2^label_E)),\n         label_P = ifelse(label_P == 0, 1, ifelse(label_P == 16, 0, 1/2^label_P)))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preprocess</span>"
    ]
  },
  {
    "objectID": "data-preprocess.html#data-process-by-mcmodel",
    "href": "data-preprocess.html#data-process-by-mcmodel",
    "title": "2  Data preprocess",
    "section": "2.2 Data Process By mcmodel",
    "text": "2.2 Data Process By mcmodel\nExtract cycle and repeat from file names.\n\nlibrary(stringr)\nget_cycle = function(filename){\n  str_extract(filename, \"cycle[0-9]{2}\")  |&gt; \n    str_remove(\"cycle\")  |&gt; \n    as.numeric()\n}\n\nget_repeat = function(filename){\n  str_extract(filename, \"experiment[0-9]\")  |&gt; \n    str_remove(\"experiment\")  |&gt; \n    as.numeric()\n}\n\nRead in melting curve and extract data from temperature 80 to 90 °C, transform raw signal to step 0.1 signal by interpolations.\n\nlibrary(mcmodel)\n\nmc0512 = lapply(seq_along(files), function(i){\n  filename = files[[i]]\n  all = read_quantstudio(filename)\n  sample = plate  |&gt; \n    mutate(cycle = get_cycle(filename), rep = get_repeat(filename))\n  mc = quantstudio2mc(all, primer = \"V4\", plate = sample)  |&gt; \n    filterData(from = 80, to = 90)  |&gt; \n    transformData(step = 0.1)\n  return(mc)\n})\n\nTransform MeltingCurve object to data frame.\n\ndata0512 = lapply(mc0512, mc_tbl2wider) |&gt; bind_rows()\n\nhead(data0512)\n\n# A tibble: 6 × 105\n  experiment_date well_position label_E label_P cycle   rep  T80.1  T80.2  T80.3\n  &lt;date&gt;          &lt;chr&gt;           &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 2023-05-13      A1                  1       0    30     1 0.0680 0.0680 0.0680\n2 2023-05-13      A2                  1       0    30     1 0.0778 0.0789 0.0790\n3 2023-05-13      A3                  1       0    30     1 0.0718 0.0720 0.0720\n4 2023-05-13      A4                  0       1    30     1 0.0623 0.0611 0.0609\n5 2023-05-13      A5                  0       1    30     1 0.0339 0.0339 0.0351\n6 2023-05-13      A6                  0       1    30     1 0.0344 0.0368 0.0382\n# ℹ 96 more variables: T80.4 &lt;dbl&gt;, T80.5 &lt;dbl&gt;, T80.6 &lt;dbl&gt;, T80.7 &lt;dbl&gt;,\n#   T80.8 &lt;dbl&gt;, T80.9 &lt;dbl&gt;, T81 &lt;dbl&gt;, T81.1 &lt;dbl&gt;, T81.2 &lt;dbl&gt;, T81.3 &lt;dbl&gt;,\n#   T81.4 &lt;dbl&gt;, T81.5 &lt;dbl&gt;, T81.6 &lt;dbl&gt;, T81.7 &lt;dbl&gt;, T81.8 &lt;dbl&gt;,\n#   T81.9 &lt;dbl&gt;, T82 &lt;dbl&gt;, T82.1 &lt;dbl&gt;, T82.2 &lt;dbl&gt;, T82.3 &lt;dbl&gt;, T82.4 &lt;dbl&gt;,\n#   T82.5 &lt;dbl&gt;, T82.6 &lt;dbl&gt;, T82.7 &lt;dbl&gt;, T82.8 &lt;dbl&gt;, T82.9 &lt;dbl&gt;, T83 &lt;dbl&gt;,\n#   T83.1 &lt;dbl&gt;, T83.2 &lt;dbl&gt;, T83.3 &lt;dbl&gt;, T83.4 &lt;dbl&gt;, T83.5 &lt;dbl&gt;,\n#   T83.6 &lt;dbl&gt;, T83.7 &lt;dbl&gt;, T83.8 &lt;dbl&gt;, T83.9 &lt;dbl&gt;, T84 &lt;dbl&gt;, …",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preprocess</span>"
    ]
  },
  {
    "objectID": "data-preprocess.html#save-modeling-data",
    "href": "data-preprocess.html#save-modeling-data",
    "title": "2  Data preprocess",
    "section": "2.3 Save Modeling Data",
    "text": "2.3 Save Modeling Data\nSave data frame to disk.\n\nwrite.csv(data0512, file = \"data-clean/20230512.csv\", row.names = FALSE)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data preprocess</span>"
    ]
  },
  {
    "objectID": "model-selection.html",
    "href": "model-selection.html",
    "title": "3  Model Selection",
    "section": "",
    "text": "3.1 Global setting\nHere we load packages and define several frequently used variables.\n# load required packages\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(mcmodel)\nlibrary(cowplot)\n\n# default theme\ntheme_set(theme_bw() +\n            theme(legend.key.size = unit(0.4,'cm'),\n                  legend.key.height = unit(.4, 'cm')))\n\n# global setting\nstrain_label = c(\"label_E\", \"label_P\")\nstrain_name = c(\"EC\",\"PP\")\nstrain_color = c(\"red3\", \"purple3\")\n\n# well position\nec_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(1:3, each = 16))\npp_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(4:6, each = 16))\ngradient_matrix_well = paste0(rep(LETTERS[1:16],times = 16), rep(7:22,each = 16))\nstrain_single_well = list(EC = ec_single_well, PP = pp_single_well)\n\n# set seed\nset.seed(0)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model Selection</span>"
    ]
  },
  {
    "objectID": "model-selection.html#data-preparation",
    "href": "model-selection.html#data-preparation",
    "title": "3  Model Selection",
    "section": "3.2 Data Preparation",
    "text": "3.2 Data Preparation\n\nmc_ml_data = read.csv(\"data-clean/20230512.csv\") |&gt; \n  filter(well_position %in% gradient_matrix_well,\n                rep == 1,\n                cycle == 30) |&gt; \n  select(starts_with('label_'), starts_with('T')) |&gt; \n  mutate(label_E = log2(label_E), label_P = log2(label_P))\n\nwrite.csv(mc_ml_data, 'data-clean/model-selection-data.csv')",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model Selection</span>"
    ]
  },
  {
    "objectID": "model-selection.html#models",
    "href": "model-selection.html#models",
    "title": "3  Model Selection",
    "section": "3.3 Models",
    "text": "3.3 Models\n\n# import linear models\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import Ridge\nfrom sklearn.linear_model import Lasso\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.neighbors import KNeighborsRegressor\n\n# import ensemble regressors\nfrom sklearn.ensemble import AdaBoostRegressor\nfrom sklearn.ensemble import BaggingRegressor\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.ensemble import RandomForestRegressor\n\n# import decision tree\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.svm import LinearSVR\n\n# import additional multioutput regressors\nfrom sklearn.multioutput import RegressorChain, MultiOutputRegressor\n\nbase_regressor = GradientBoostingRegressor(random_state=1)\nmulti_output_gradient_boosting_regression = MultiOutputRegressor(base_regressor)\n\nbase_regressor = LinearSVR(dual=True, max_iter=5000)\nmulti_output_linear_svr_regression = MultiOutputRegressor(base_regressor)\n\n# 创建Ridge基础估计器并封装为MultiOutputRegressor\nbase_regressor = Ridge(alpha=1.0)\nmulti_output_ridge_regression = MultiOutputRegressor(base_regressor)\n\n# 创建Lasso基础估计器并封装为MultiOutputRegressor\nbase_regressor = Lasso(alpha=1.0, max_iter=3000)\nmulti_output_lasso_regression = MultiOutputRegressor(base_regressor)\n\n# 创建ElasticNet基础估计器并封装为MultiOutputRegressor\nbase_regressor = ElasticNet(alpha=1.0, l1_ratio=0.5, max_iter=3000)\nmulti_output_elasticnet_regression = MultiOutputRegressor(base_regressor)\n\n# 创建Bagging基础估计器并封装为MultiOutputRegressor\nbase_regressor = BaggingRegressor(random_state=1)\nmulti_output_bagging_regression = MultiOutputRegressor(base_regressor)\n\n# 创建AdaBoost基础估计器并封装为MultiOutputRegressor\nbase_regressor = AdaBoostRegressor(random_state=1)\nmulti_output_adaboost_regression = MultiOutputRegressor(base_regressor)\n\n# 创建不同的回归模型对象\nmodels = {\n  'Linear': LinearRegression(),\n  'Ridge': multi_output_ridge_regression,\n  'Lasso': multi_output_lasso_regression,\n  'ElasticNet': multi_output_elasticnet_regression,\n  'K-Neighbors': KNeighborsRegressor(),\n  'Decision Tree': DecisionTreeRegressor(),\n  'RandForest': RandomForestRegressor(),\n  'Bagging': multi_output_bagging_regression,\n  'AdaBoost': multi_output_adaboost_regression,\n  'GradBoost': multi_output_gradient_boosting_regression,\n  'SVM': multi_output_linear_svr_regression\n  }",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model Selection</span>"
    ]
  },
  {
    "objectID": "model-selection.html#model-metrics",
    "href": "model-selection.html#model-metrics",
    "title": "3  Model Selection",
    "section": "3.4 Model Metrics",
    "text": "3.4 Model Metrics\nTest different models with same training data, and fetch the model metrics of r2_score, mean_squared_error and mean_absolute_error.\n\n# import required modules\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split, KFold\nfrom sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error\nimport warnings\n\nclass meltingCurveExperiment:\n  '''\n  define a meltingCurveExperiment\n  '''\n  \n  def __init__(self, file=None, data=None, test_size=0.05):\n    # deal with input\n    if data is not None:\n      if file is not None:\n        warnings.warn(\"`data` will be used.\", UserWarning)\n        data = data\n    elif file is not None:\n      # 如果只提供了 file，则从文件加载数据\n      data = pd.read_csv(file)\n    else:\n      # 如果没有提供 file 和 data，则引发错误\n      raise ValueError(\"You must provide a `file` or `data` argument.\")\n        \n    data = data.dropna(axis=1, how='all')\n    data = data.dropna()\n    self.data = data\n    X = data.filter(regex = \"^T\")\n    y = data.filter(regex = \"^label_\")\n    self.X_train, self.X_test, self.y_train, self.y_test = (\n      train_test_split(X, y, test_size=test_size)\n    )\n            \n  def cross_validate_regression_models(self, models, cv=10):\n    \"\"\"\n    对给定的多个回归模型使用十折交叉验证进行建模，并计算多个参数。\n    \n    参数:\n      models: 字典，包含不同名称的回归模型对象，键为模型名称，值为模型对象。\n      cv: 整数，指定交叉验证的折数，默认为10。\n      \n    返回值:\n      results: 字典，包含每个模型的参数值，键为模型名称，值为参数值的字典，\n               其中包含MSE、R^2、MAE等。\n    \"\"\"\n    results = {}\n    kf = KFold(n_splits=cv, shuffle=True, random_state=42)\n    \n    for model_name, model in models.items():\n      rmse_values = []\n      r2_values = []\n      mae_values = []\n      \n      for train_idx, test_idx in kf.split(self.X_train):\n        X_train_fold = self.X_train.iloc[train_idx]\n        X_test_fold = self.X_train.iloc[test_idx]\n        y_train_fold = self.y_train.iloc[train_idx]\n        y_test_fold = self.y_train.iloc[test_idx]\n        \n        # 使用模型对训练集进行拟合\n        model.fit(X_train_fold, y_train_fold)\n        \n        # 使用训练好的模型进行预测\n        y_pred_fold = model.predict(X_test_fold)\n        \n        # 计算每个折叠的均方误差、R^2值、平均绝对误差和解释方差得分\n        mse_fold = mean_squared_error(y_test_fold, y_pred_fold)\n        r2_fold = r2_score(y_test_fold, y_pred_fold)\n        mae_fold = mean_absolute_error(y_test_fold, y_pred_fold)\n        \n        rmse_values.append(np.sqrt(mse_fold))\n        r2_values.append(r2_fold)\n        mae_values.append(mae_fold)\n        \n        # 将结果存储在字典中\n        results[model_name] = {'rmse': rmse_values, \n        'rsq': r2_values, \n        'mae': mae_values}\n        self.results = results\n            \n                      \n  def results_to_df(self, extra = None):\n    data_dict = self.results\n    raw = []\n    for i in data_dict.keys():\n      for j in data_dict[i].keys():\n        raw.append({'model':i, 'metric':j, 'value': data_dict[i][j]})\n        df = pd.DataFrame(raw)\n        df = df.explode('value').reset_index(drop=True)\n        \n    if extra is not None:\n      for col_name, col_data in extra.items():\n        df[col_name] = col_data\n        \n    # return\n    return(df)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model Selection</span>"
    ]
  },
  {
    "objectID": "model-selection.html#evaluation",
    "href": "model-selection.html#evaluation",
    "title": "3  Model Selection",
    "section": "3.5 Evaluation",
    "text": "3.5 Evaluation\nWe test different model in Python.\n\nexp = meltingCurveExperiment(file='data-clean/model-selection-data.csv')\nexp.cross_validate_regression_models(models=models)\nexp.results_to_df().to_csv('data-clean/model-selection-metric.csv', index = False)\n\nMetric comparison revealed that ensemble machine learning methods, including Bagging, GradBoost and RandForest, have the best prediction performances Figure 3.1.\n\nmodel_ordered = paste('Linear,Lasso,Ridge,ElasticNet,SVM,GradBoost,AdaBoost',\n                      'Bagging,K-Neighbors,Decision Tree,RandForest',\n                      sep = \",\")  |&gt; str_split_1(\",\")\nmc_ml_cv_metric = read.csv('data-clean/model-selection-metric.csv') |&gt; \n  mutate(model = factor(model, levels = model_ordered))\nmetrics = mc_ml_cv_metric$metric |&gt; unique()\n\np_mc_ml_cv_metric = lapply(metrics, function(x){\n  mc_ml_cv_metric |&gt; \n    filter(metric == x) |&gt; \n    ggplot(aes(model, value)) +\n    geom_boxplot(outliers = FALSE) +\n    labs(x = NULL, y = x) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1.1, vjust = 1.1))\n})\n\nplot_grid(plotlist = p_mc_ml_cv_metric, ncol = 3, labels = \"auto\")\n\nggsave(filename = \"figures/figure3a.jpg\")\n\nSaving 8 x 3.2 in image\n\n\n\n\n\n\n\n\nFigure 3.1: Assessment of various machine learning algorisms in modeling and prediction with melting curve data.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Model Selection</span>"
    ]
  },
  {
    "objectID": "two-species-modeling.html",
    "href": "two-species-modeling.html",
    "title": "4  Dual-species Modelling",
    "section": "",
    "text": "4.1 Global setting\nHere we load packages and define several frequently used variables.\n# load required packages\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(mcmodel)\nlibrary(cowplot)\n\n# default theme\ntheme_set(theme_bw() +\n            theme(legend.key.size = unit(0.4,'cm'),\n                  legend.key.height = unit(.4, 'cm')))\n\n# global setting\nstrain_label = c(\"label_E\", \"label_P\")\nstrain_name = c(\"EC\",\"PP\")\nstrain_color = c(\"red3\", \"purple3\")\n\n# well position\nec_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(1:3, each = 16))\npp_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(4:6, each = 16))\ngradient_matrix_well = paste0(rep(LETTERS[1:16],times = 16), rep(7:22,each = 16))\nstrain_single_well = list(EC = ec_single_well, PP = pp_single_well)\n\n# set seed\nset.seed(0)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dual-species Modelling</span>"
    ]
  },
  {
    "objectID": "two-species-modeling.html#two-species-design",
    "href": "two-species-modeling.html#two-species-design",
    "title": "4  Dual-species Modelling",
    "section": "4.2 Two-species design",
    "text": "4.2 Two-species design\nThe plate setting used in melting curve analysis is provided in a csv file. Original value for each column is the times of two-fold dilution, and we transform them into DNA quantity as related to the original concentration (assumed to be 1). Note: a label value of 16 means not contain this species.\n\n# read plate setting\nplate_file = xfun::magic_path(\"modeling-plate-labels.csv\")\nplate = read.csv(plate_file)\nplate2 = plate |&gt; \n  drop_na() |&gt; \n  mutate(label_E = ifelse(label_E == 0, 1, ifelse(label_E == 16, 0, 1/2^label_E)),\n         label_P = ifelse(label_P == 0, 1, ifelse(label_P == 16, 0, 1/2^label_P)))\n\nLayout of gradient dilution matrix Figure 4.1.\n\np_concentration = lapply(seq_along(strain_label), function(i){\n  plot_384_single_concentration(plate2, strain_label[[i]], well_size = 1.5) + \n    scale_color_gradient(high = strain_color[[i]], \n                         low = \"white\", \n                         trans = \"log2\", \n                         na.value = \"grey90\") +\n    coord_equal(xlim = c(6.5,22.5)) +\n    theme(legend.position = 'none',\n          axis.text = element_blank())\n})\n\np_concentration[[1]] = p_concentration[[1]] + \n  labs(x = \" \", y = expression(log[2]*Q[1]~(low %-&gt;% high)))\n\np_concentration[[2]] = p_concentration[[2]] + \n  labs(x = expression(log[2]*Q[2]~(high %-&gt;% low)), y = \" \")\n\nplate3 = plate2 |&gt; \n  dplyr::filter(well_position %in% gradient_matrix_well)\n\np_matrix = plot_384_community_structure(plate3) + \n  scale_fill_manual(values = c(\"red3\",\"purple3\")) +\n  coord_equal(xlim = c(6.5,22.5)) +\n  theme(legend.position = 'none',\n        axis.text = element_blank()) +\n  labs(x = expression(log[2]*Q[2]~(high %-&gt;% low)),\n       y = expression(log[2]*Q[1]~(low %-&gt;% high)))\n\nplot_grid(p_concentration[[1]], \n          p_concentration[[2]], \n          p_matrix, \n          align = 'hv',\n          ncol = 3,\n          labels = \"auto\")\n\nWarning in scale_color_gradient(high = strain_color[[i]], low = \"white\", : log-2 transformation introduced infinite values.\nlog-2 transformation introduced infinite values.\n\nggsave(filename = \"figures/figure2a.jpg\")\n\nSaving 7 x 2.45 in image\n\n\n\n\n\n\n\n\nFigure 4.1: Layout of gradient dilution matrix.\n\n\n\n\n\nMelting curves of gradient dilution matrix Figure 4.2.\n\n# read qPCR run results\nraw_file = xfun::magic_path(\"cycle30-experiment1.txt\")\nquantstudio_raw = read_quantstudio(raw_file)\nmc = quantstudio2mc(quantstudio_raw, plate = plate2, primer = \"V4\")\nmc = filterData(mc, from = 80, to = 90) |&gt; \n  transformData(step = 0.1)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dual-species Modelling</span>"
    ]
  },
  {
    "objectID": "two-species-modeling.html#gradient-dilution-matrix",
    "href": "two-species-modeling.html#gradient-dilution-matrix",
    "title": "4  Dual-species Modelling",
    "section": "4.3 Gradient Dilution Matrix",
    "text": "4.3 Gradient Dilution Matrix\n\nmc_df = mc2tbl(mc)\nmc_df_matrix = mc_df |&gt; \n  dplyr::filter(well_position %in% gradient_matrix_well) |&gt; \n  dplyr::mutate_at(c('label_E','label_P'), \n                   function(x) log2(x) |&gt; as_factor() |&gt; fct_rev())\n\nggplot(mc_df_matrix, aes(temperature, derivative, group = well_position)) +\n  geom_line() +\n  scale_x_continuous(position = 'top') +\n  facet_grid(label_E ~ label_P, switch = 'y') +\n  labs(x = expression(log[2]*Q[2]~(high %-&gt;% low)),\n       y = expression(log[2]*Q[1]~(low %-&gt;% high))) +\n  theme(legend.position = \"none\",\n        panel.spacing = unit(1, \"pt\"),\n        axis.ticks = element_blank(),\n        axis.text = element_blank(),)\n\nggsave(\"figures/figure2c.jpg\")\n\nSaving 7 x 5.6 in image\n\n\n\n\n\n\n\n\nFigure 4.2: Melting curves of gradient dilution matrix.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dual-species Modelling</span>"
    ]
  },
  {
    "objectID": "two-species-modeling.html#random-forest-modelling",
    "href": "two-species-modeling.html#random-forest-modelling",
    "title": "4  Dual-species Modelling",
    "section": "4.4 Random Forest Modelling",
    "text": "4.4 Random Forest Modelling\n\n# data\nmc_ml_data = read.csv(\"data-clean/20230512.csv\") |&gt; \n  dplyr::filter(well_position %in% gradient_matrix_well,\n                cycle == 30, rep == 2) |&gt; \n  mutate(label_E = log2(label_E), label_P = log2(label_P))\n\ndata = initial_split(mc_ml_data)\ndata_train = training(data)\ndata_test = testing(data)\n\n\nlm_spec = linear_reg(engine = \"lm\")\n\nrf_spec = rand_forest(mode = \"regression\", trees = 1000) |&gt; \n  set_engine(\"ranger\", importance = 'impurity', num.threads = 10)\n\nplot_model_metric = function(predictions, model_metrics, truth_label, color){\n  annotation = paste(model_metrics[['.metric']], \n                     format(round(model_metrics[['.estimate']], 2), digits = 2), \n                     sep = \": \", \n                     collapse = \"\\n\")\n  ggplot(predictions, aes(.data[[truth_label]], `.pred`, color = I(color))) +\n    geom_point(shape = 21) +\n    geom_abline(slope = 1, linetype = 'dashed', color = color) +\n    annotate(\"text\", x = -Inf, y = Inf, color = I(color), label = annotation, \n             hjust = -0.1, vjust = 1.1) +\n    coord_equal() +\n    xlim(c(-16,0)) + ylim(c(-16, 0)) +\n    labs(x = expression(log[2]*Q[true]), y = expression(log[2]*Q[pred]))\n}\n\n\np_lm_predict = lapply(seq_along(strain_label), function(i){\n  train = data_train |&gt; select(matches(strain_label[[i]]), starts_with(\"T\"))\n  test = data_test  |&gt; select(matches(strain_label[[i]]), starts_with(\"T\"))\n  recipe = recipe(as.formula(paste(strain_label[[i]], '.', sep = '~')), \n                  data = train)\n  \n  fit = workflow() |&gt; \n    add_recipe(recipe) |&gt; \n    add_model(lm_spec) |&gt; \n    fit(train)\n  \n  prediction = augment(fit, new_data = test) \n  \n  metric = prediction |&gt; \n    metrics(truth = strain_label[[i]], estimate = .pred) \n  \n  plot_model_metric(prediction, metric, strain_label[[i]], strain_color[[i]]) + \n    labs(subtitle = 'Linear')\n})\n\nWarning in predict.lm(object = object$fit, newdata = new_data, type =\n\"response\", : prediction from rank-deficient fit; consider predict(.,\nrankdeficient=\"NA\")\n\nWarning in predict.lm(object = object$fit, newdata = new_data, type =\n\"response\", : prediction from rank-deficient fit; consider predict(.,\nrankdeficient=\"NA\")\n\np_rf_predict =  lapply(seq_along(strain_label), function(i){\n  train = data_train |&gt; select(matches(strain_label[[i]]), starts_with(\"T\"))\n  test = data_test  |&gt; select(matches(strain_label[[i]]), starts_with(\"T\"))\n  recipe = recipe(as.formula(paste(strain_label[[i]], '.', sep = '~')), \n                  data = train)\n  \n  fit = workflow()  |&gt; \n    add_recipe(recipe)  |&gt; \n    add_model(rf_spec) |&gt; \n    fit(train)\n  \n  prediction = augment(fit, new_data = test) \n  \n  metric = prediction |&gt; \n    metrics(truth = strain_label[[i]], estimate = .pred)\n  \n  plot_model_metric(prediction, metric, strain_label[[i]], strain_color[[i]]) + \n    labs(subtitle = 'RandForest')\n})\n\n\nplot_grid(plotlist = c(p_lm_predict, p_rf_predict), ncol = 4, labels = letters[4:7])\n\nWarning: Removed 6 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\nWarning: Removed 3 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\nggsave(filename = \"figures/figure3d.jpg\")\n\nSaving 8.5 x 2.97 in image",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dual-species Modelling</span>"
    ]
  },
  {
    "objectID": "model-optimization.html",
    "href": "model-optimization.html",
    "title": "5  Model Optimization",
    "section": "",
    "text": "5.1 Global setting\nHere we load packages and define several frequently used variables.\n# load required packages\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(mcmodel)\nlibrary(cowplot)\n\n# default theme\ntheme_set(theme_bw() +\n            theme(legend.key.size = unit(0.4,'cm'),\n                  legend.key.height = unit(.4, 'cm')))\n\n# global setting\nstrain_label = c(\"label_E\", \"label_P\")\nstrain_name = c(\"EC\",\"PP\")\nstrain_color = c(\"red3\", \"purple3\")\n\n# well position\nec_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(1:3, each = 16))\npp_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(4:6, each = 16))\ngradient_matrix_well = paste0(rep(LETTERS[1:16],times = 16), rep(7:22,each = 16))\nstrain_single_well = list(EC = ec_single_well, PP = pp_single_well)\n\n# set seed\nset.seed(0)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Model Optimization</span>"
    ]
  },
  {
    "objectID": "model-optimization.html#data-functions",
    "href": "model-optimization.html#data-functions",
    "title": "5  Model Optimization",
    "section": "5.2 Data, Functions",
    "text": "5.2 Data, Functions\n\nall_data = read.csv(\"data-clean/20230512.csv\") |&gt; \n  filter(well_position %in% gradient_matrix_well) |&gt; \n  mutate(label_E = log2(label_E), label_P = log2(label_P))\n\n\n# get metric with specified parameters\nrf_metric = function(train_data, \n                     test_data = NULL, \n                     y = \"label_E\", \n                     X = starts_with(\"T\"), \n                     ...){\n  model = rand_forest(mode = \"regression\", trees = 1000) |&gt; \n    set_engine(\"ranger\", importance = 'impurity', num.threads = 10)\n  train_data = train_data |&gt; select(all_of(y), all_of(X))\n  formula = as.formula(paste(y, \".\", sep = \"~\"))\n  fit = workflow() |&gt; \n    add_recipe(recipe(formula, data = train_data)) |&gt; \n    add_model(model) |&gt; \n    fit(train_data)\n  prediction = augment(fit, new_data = test_data)\n  extra = enquos(...)\n  metric = prediction |&gt; \n    metrics(truth = y, estimate = .pred) |&gt; \n    mutate(!!!extra)\n  return(metric)\n}\n\n# to plot metric\nplot_metric = function(data, x, y = \".estimate\", metric = 'rsq', color = \"black\"){\n  data |&gt; filter(.metric == metric) |&gt; \n    ggplot(aes(.data[[x]], .data[[y]], color = I(color))) +\n    geom_point(shape = 21) +\n    geom_smooth(method = \"loess\") +\n    labs(x = x, y = metric)\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Model Optimization</span>"
    ]
  },
  {
    "objectID": "model-optimization.html#size-of-training-data",
    "href": "model-optimization.html#size-of-training-data",
    "title": "5  Model Optimization",
    "section": "5.3 Size of Training Data",
    "text": "5.3 Size of Training Data\nUse one experiment data to train, and the other experiment data to test.\n\nrep2 = all_data |&gt; \n  dplyr::filter(rep == 2,\n                cycle == 30) |&gt; \n  dplyr::select(starts_with('label_'), starts_with('T'))\n\nrep3 = all_data |&gt; \n  dplyr::filter(rep == 3,\n                cycle == 30) |&gt; \n  dplyr::select(starts_with('label_'), starts_with('T'))\n\nUsing different size of training data to fit and evaluate the prediction result of same test data.\n\nprop = rep(seq(0.05, 0.95, by = 0.05), each = 10) \nrf_rep_metric = lapply(prop, function(p){\n  lapply(seq_along(strain_label), function(i){\n    data_split = initial_split(rep2, prop = p)\n    ylab = strain_label[[i]]\n    train = training(data_split) |&gt; select(matches(ylab), starts_with(\"T\"))\n    test = rep3 |&gt; select(any_of(ylab), starts_with(\"T\"))\n    rf_metric(train, test, ylab, prop = nrow(train), species = ylab)\n  }) |&gt; bind_rows()\n}) |&gt; bind_rows()\n\n\np_grad = lapply(seq_along(strain_label), function(i){\n  lapply(c('rmse','rsq','mae'), function(m){\n    df = rf_rep_metric |&gt; \n      dplyr::filter(species == strain_label[[i]])\n    plot_metric(df, x = \"prop\", metric = m, color = I(strain_color[[i]])) +\n      labs(x = NULL, y = m)\n  })\n}) |&gt; unlist(recursive = FALSE)\n\nplot_grid(plotlist = p_grad, ncol = 3, align = \"hv\", labels = \"auto\")\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Model Optimization</span>"
    ]
  },
  {
    "objectID": "model-optimization.html#thermo-cycles",
    "href": "model-optimization.html#thermo-cycles",
    "title": "5  Model Optimization",
    "section": "5.4 Thermo Cycles",
    "text": "5.4 Thermo Cycles\n\nthermo_cycle_metric = lapply(c(30, 35, 40), function(c){\n  mc_ml_data = all_data |&gt; \n    filter(cycle == c, rep %in% 2:3)\n  lapply(1:10, function(x){\n    data = initial_split(mc_ml_data)\n    results = lapply(seq_along(strain_label), function(i){\n      train = training(data)\n      test = testing(data)\n      strain = strain_label[[i]]\n      rf_metric(train, test, y = strain, cycle = c, species = strain)\n    })\n    \n    bind_rows(results)\n  }) |&gt; bind_rows()\n}) |&gt; \n  bind_rows() |&gt; \n  mutate(cycle = paste(cycle, \"x\"))\n\n\nlibrary(ggpubr)\n\n\nAttaching package: 'ggpubr'\n\n\nThe following object is masked from 'package:cowplot':\n\n    get_legend\n\n# to plot metric\nboxplot_metric = function(data, x, y = \".estimate\", metric = 'rsq', color = \"black\"){\n  data |&gt; filter(.metric == metric) |&gt; \n    ggplot(aes(.data[[x]], .data[[y]], color = I(color))) +\n    geom_boxplot(outliers = FALSE) +\n    geom_jitter(width = 0.2) +\n    stat_compare_means(label = \"p.format\", vjust = 0.5) +\n    labs(x = NULL, y = metric)\n}\n\np_cycle = lapply(seq_along(strain_label), function(i){\n  lapply(c('rmse','rsq','mae'), function(m){\n    df = thermo_cycle_metric |&gt; \n      dplyr::filter(species == strain_label[[i]])\n    boxplot_metric(df, x = \"cycle\", metric = m, color = I(strain_color[[i]]))\n  })\n}) |&gt; unlist(recursive = FALSE)\n\nplot_grid(plotlist = p_cycle, align = \"hv\", ncol = 3, labels = \"auto\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Model Optimization</span>"
    ]
  },
  {
    "objectID": "model-optimization.html#temperature-increment-rate",
    "href": "model-optimization.html#temperature-increment-rate",
    "title": "5  Model Optimization",
    "section": "5.5 Temperature Increment Rate",
    "text": "5.5 Temperature Increment Rate\n\nrate_map = c(`1` = \"0.015\", `2` = \"0.03 °C/s\")\nrate_metric = lapply(c(1, 2), function(r){\n  mc_ml_data = all_data |&gt; \n    filter(cycle == 30, rep == r)\n  lapply(1:10, function(x){\n    data = initial_split(mc_ml_data)\n    results = lapply(seq_along(strain_label), function(i){\n      train = training(data)\n      test = testing(data)\n      strain = strain_label[[i]]\n      rf_metric(train, test, y = strain, rate = r, species = strain)\n    })\n    \n    bind_rows(results)\n  }) |&gt; bind_rows()\n}) |&gt; bind_rows() |&gt; \n  rowwise() |&gt; \n  mutate(rate = rate_map[[rate]])\n\n\np_rate = lapply(seq_along(strain_label), function(i){\n  lapply(c('rmse','rsq','mae'), function(m){\n    df = rate_metric |&gt; \n      dplyr::filter(species == strain_label[[i]])\n    boxplot_metric(df, x = \"rate\", metric = m, color = I(strain_color[[i]])) +\n      labs(x = NULL, y = m)\n  })\n}) |&gt; unlist(recursive = FALSE)\n\nplot_grid(plotlist = p_rate, align = \"hv\", ncol = 3, labels = \"auto\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Model Optimization</span>"
    ]
  },
  {
    "objectID": "model-optimization.html#combined-results",
    "href": "model-optimization.html#combined-results",
    "title": "5  Model Optimization",
    "section": "5.6 Combined Results",
    "text": "5.6 Combined Results\n\ngglist = c(p_cycle[c(2,5)], p_rate[c(2,5)])\nplot_grid(\n  plot_grid(plotlist = p_grad[c(2,5)], labels = c(\"a\",\"b\")), \n  plot_grid(plotlist = gglist, nrow = 1, \n            align = \"v\",\n            rel_widths = c(1.2,1.2,1,1), \n            labels = letters[3:6]), \n  ncol = 1)\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nggsave(\"figures/figure4.jpg\")\n\nSaving 7 x 5.6 in image",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Model Optimization</span>"
    ]
  },
  {
    "objectID": "method-evaluation.html",
    "href": "method-evaluation.html",
    "title": "6  Method Evaluation",
    "section": "",
    "text": "6.1 Global setting\nHere we load packages and define several frequently used variables.\n# load required packages\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(mcmodel)\nlibrary(cowplot)\n\n# default theme\ntheme_set(theme_bw() +\n            theme(legend.key.size = unit(0.4,'cm'),\n                  legend.key.height = unit(.4, 'cm')))\n\n# global setting\nstrain_label = c(\"label_E\", \"label_P\")\nstrain_name = c(\"EC\",\"PP\")\nstrain_color = c(\"red3\", \"purple3\")\n\n# well position\nec_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(1:3, each = 16))\npp_single_well = paste0(rep(LETTERS[1:16], times = 3), rep(4:6, each = 16))\ngradient_matrix_well = paste0(rep(LETTERS[1:16],times = 16), rep(7:22,each = 16))\nstrain_single_well = list(EC = ec_single_well, PP = pp_single_well)\n\n# set seed\nset.seed(0)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Method Evaluation</span>"
    ]
  },
  {
    "objectID": "method-evaluation.html#functions",
    "href": "method-evaluation.html#functions",
    "title": "6  Method Evaluation",
    "section": "6.2 Functions",
    "text": "6.2 Functions\n\nplot_syncom = function(data){\n  ggplot(data, aes(sample, quantity, fill = species)) +\n  geom_col() +\n  theme(legend.position = \"top\") +\n  scale_x_discrete(labels = function(x) {\n    x[seq(2, length(x), 2)] &lt;- \"\" \n    x\n  })\n}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Method Evaluation</span>"
    ]
  },
  {
    "objectID": "method-evaluation.html#by-16s-rrna-gene-sequencing",
    "href": "method-evaluation.html#by-16s-rrna-gene-sequencing",
    "title": "6  Method Evaluation",
    "section": "6.3 By 16S rRNA gene sequencing",
    "text": "6.3 By 16S rRNA gene sequencing\nUse DADA2 to process 16S rRNA gene sequencing data.\n\n# raw data\ndir = '/Volumes/Data/Projects/MbPL2024051607'\nfastq_files = list.files(path = dir, pattern = \".merged.fastq.gz\", \n                         recursive = TRUE, full.names = TRUE)\nsample.names = dirname(fastq_files) |&gt; basename()\n\n# filter and trim sequence\nfilt_path = file.path(\"./data-raw/application-ngs\")\nif (!dir.exists(filt_path)) dir.create(filt_path)\n\nlibrary(dada2)\n\nfor (i in seq_along(fastq_files)) {\n  fastq_filt = file.path(filt_path, basename(fastq_files[i]))\n  filterAndTrim(fastq_files[i], fastq_filt, \n                maxN = 0, maxEE = 2, truncQ = 2, rm.phix = TRUE,\n                compress = TRUE, multithread = TRUE)\n}\n\n\nlibrary(dada2)\nngs_path = \"data-raw/application-ngs\"\n\n# learn error\nerr = learnErrors(ngs_path, multithread = TRUE, verbose = FALSE)\n\n104262362 total bases in 412108 reads from 3 samples will be used for learning the error rates.\n\n# denoise\ndadaFs = derepFastq(ngs_path) |&gt; \n  dada(err = err, multithread = TRUE)\n\nSample 1 - 138894 reads in 6925 unique sequences.\nSample 2 - 135081 reads in 6290 unique sequences.\nSample 3 - 138133 reads in 6763 unique sequences.\nSample 4 - 146414 reads in 5969 unique sequences.\nSample 5 - 143670 reads in 5975 unique sequences.\nSample 6 - 140401 reads in 6060 unique sequences.\nSample 7 - 143489 reads in 6063 unique sequences.\nSample 8 - 143486 reads in 5979 unique sequences.\nSample 9 - 146415 reads in 5965 unique sequences.\nSample 10 - 142644 reads in 5907 unique sequences.\nSample 11 - 131972 reads in 6048 unique sequences.\nSample 12 - 135238 reads in 6653 unique sequences.\nSample 13 - 142180 reads in 5674 unique sequences.\nSample 14 - 146281 reads in 6423 unique sequences.\nSample 15 - 136775 reads in 5558 unique sequences.\nSample 16 - 131760 reads in 5484 unique sequences.\nSample 17 - 133423 reads in 5706 unique sequences.\nSample 18 - 146130 reads in 6135 unique sequences.\nSample 19 - 142953 reads in 6105 unique sequences.\nSample 20 - 146291 reads in 6521 unique sequences.\nSample 21 - 146326 reads in 6745 unique sequences.\nSample 22 - 140786 reads in 5726 unique sequences.\nSample 23 - 145401 reads in 6248 unique sequences.\nSample 24 - 142975 reads in 6594 unique sequences.\nSample 25 - 125641 reads in 5031 unique sequences.\nSample 26 - 126698 reads in 4575 unique sequences.\nSample 27 - 135369 reads in 5247 unique sequences.\nSample 28 - 138824 reads in 5184 unique sequences.\nSample 29 - 143340 reads in 4895 unique sequences.\nSample 30 - 141025 reads in 4419 unique sequences.\nSample 31 - 144200 reads in 5132 unique sequences.\nSample 32 - 128555 reads in 4814 unique sequences.\nSample 33 - 147407 reads in 4984 unique sequences.\nSample 34 - 140217 reads in 4539 unique sequences.\nSample 35 - 141868 reads in 4729 unique sequences.\nSample 36 - 147145 reads in 5012 unique sequences.\nSample 37 - 122510 reads in 4288 unique sequences.\nSample 38 - 138030 reads in 4386 unique sequences.\nSample 39 - 135522 reads in 4804 unique sequences.\nSample 40 - 139861 reads in 4406 unique sequences.\n\nnames(dadaFs) = gsub(\".merged.fastq.gz\", \"\", names(dadaFs))\n\n# build sequence table\nseqtab = makeSequenceTable(dadaFs)\n\n# remove chimera\nseqtab.nochim = removeBimeraDenovo(seqtab,\n                                   method = \"consensus\", \n                                   multithread = TRUE)\n\n# assign taxonomy\nsilva_train_set = \"~/Projects/Silva/silva_nr99_v138.1_train_set.fa.gz\"\ntaxa = assignTaxonomy(seqtab.nochim, silva_train_set, multithread = TRUE)\n\nTo use Silva database in assignTaxonomy(), you should download it at https://benjjneb.github.io/dada2/training.html.\n\n# build phyloseq object\nlibrary(phyloseq)\n\nRegistered S3 method overwritten by 'vegan':\n  method          from   \n  print.nullmodel parsnip\n\nps = phyloseq(otu_table(seqtab.nochim, taxa_are_rows = FALSE), tax_table(taxa))\n\n# merge low abundant noise\ntaxa_sums = taxa_sums(ps)\nthreshold = 0.001 * sum(taxa_sums) # threshold is 0.1%\nlow_abundance = taxa_sums &lt; threshold\nps_merged = merge_taxa(ps, taxa_names(ps)[low_abundance])\n\n# plot community\nplot_bar(ps_merged, fill = \"Genus\") +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\ntax_structure = otu_table(ps_merged) |&gt; \n  as.data.frame() |&gt; \n  tibble::rownames_to_column(\"sample\") |&gt; \n  as_tibble()\ncolnames(tax_structure)[2:4] = c(\"ppu\",\"eco\",\"others\")\nsequencing_result = tax_structure |&gt; \n  pivot_longer(cols = -sample, names_to = \"species\", values_to = \"quantity\") |&gt; \n  filter(species != 'others') |&gt; \n  mutate(method = 'NGS')\n\nplot_syncom(sequencing_result)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Method Evaluation</span>"
    ]
  },
  {
    "objectID": "method-evaluation.html#by-strain-specific-qpcr",
    "href": "method-evaluation.html#by-strain-specific-qpcr",
    "title": "6  Method Evaluation",
    "section": "6.4 By strain-specific qPCR",
    "text": "6.4 By strain-specific qPCR\n\nBuild standard curve\nCalculate strain abundance\n\n\nlibrary(mcmodel)\n\n# read qPCR results\nresult = read_quantstudio(xfun::magic_path(\"application-qPCR-result.txt\")) |&gt; \n  get_quantstudio_result() |&gt; \n  select(well_position, ct) |&gt; \n  mutate(ct = as.numeric(ct))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `ct = as.numeric(ct)`.\nCaused by warning:\n! NAs introduced by coercion\n\n# read plate layout\nplate = read.csv(xfun::magic_path(\"application-plate-layout.csv\"))\n\n# combine results and plate layout\nresult = result |&gt; left_join(plate, by = \"well_position\")\n\n\nstd_quantity = tibble(\n  well_position = paste0(rep(\"P\", 24), 1:24),\n  log2quantity = (rep(2E9, 24)/rep(10^(0:7), each = 3)) |&gt; log2()\n)\n\nstd_sample = result |&gt; \n  filter(target == 'std') |&gt; \n  select(well_position, ct)  |&gt; \n  left_join(std_quantity, by = \"well_position\") |&gt; \n  select(ct, log2quantity) |&gt; \n  na.omit()\n\n\nstd_fit = lm(log2quantity ~ ct, std_sample)\nsummary(std_fit)\n\n\nCall:\nlm(formula = log2quantity ~ ct, data = std_sample)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.35894 -0.06547  0.03517  0.09160  0.17017 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 46.71115    0.23581  198.09  &lt; 2e-16 ***\nct          -0.91748    0.01024  -89.58 7.35e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1435 on 10 degrees of freedom\nMultiple R-squared:  0.9988,    Adjusted R-squared:  0.9986 \nF-statistic:  8025 on 1 and 10 DF,  p-value: 7.35e-16\n\n\n\nunk_sample = result |&gt; \n  filter(target %in% c('EC','PP'))\n\nunk_sample_predition = broom::augment(std_fit, newdata = unk_sample)\n\n\nqPCR_result = unk_sample_predition |&gt; \n  summarise(predict = mean(.fitted, na.rm = TRUE), .by = c(sample, target)) |&gt; \n  mutate(species = if_else(target == 'EC', 'eco', 'ppu'),\n         quantity = 2^predict,\n         method = 'qPCR') |&gt; \n  select(sample, species, quantity, method)\n\n\nplot_syncom(qPCR_result)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Method Evaluation</span>"
    ]
  },
  {
    "objectID": "method-evaluation.html#by-hrm-ml-method",
    "href": "method-evaluation.html#by-hrm-ml-method",
    "title": "6  Method Evaluation",
    "section": "6.5 By HRM-ML method",
    "text": "6.5 By HRM-ML method\n\nfilename = xfun::magic_path(\"application-qPCR-result.txt\")\nplate = read.csv(xfun::magic_path(\"application-plate-layout.csv\"))\n\nall = read_quantstudio(filename)\nsample = plate |&gt; \n  mutate(cycle = 30) |&gt; \n  dplyr::filter(target == '16S')\nmc240617 = quantstudio2mc(all, plate = sample)  |&gt; \n  filterData(from = 75, to = 90, well_position = sample$well_position) |&gt; \n  transformData(step = 0.1)\n\n\ndata240617 = mc_tbl2wider(mc240617)\n\nwrite_csv(data240617, \"data-clean/20240617.csv\")\n\n\n# data\ntrain_data = read.csv(\"data-clean/20230512.csv\") |&gt; \n  dplyr::filter(well_position %in% gradient_matrix_well,\n                cycle == 30, rep == 1) |&gt; \n  dplyr::select(starts_with('label_'), starts_with('T')) |&gt; \n  mutate(label_E = log2(label_E), label_P = log2(label_P))\n\n# test data\ntest_data = read.csv(\"data-clean/20240617.csv\")\n\nlibrary(parsnip)\nlibrary(recipes)\nlibrary(workflows)\nrf_spec = rand_forest(mode = \"regression\", trees = 1000) |&gt; \n  set_engine(\"ranger\", importance = 'impurity', num.threads = 10)\n\npredictions = lapply(seq_along(strain_label), function(i){\n  label = strain_label[[i]]\n  train = train_data |&gt; select(matches(label), starts_with(\"T\"))\n  recipe = recipe(formula = as.formula(paste(label, '.', sep = '~')), \n                  data = train)\n  \n  rf_wflow = workflow()  |&gt; \n    add_recipe(recipe)  |&gt; \n    add_model(rf_spec) \n  \n  rf_fit = rf_wflow |&gt; \n    fit(train)\n  \n  prediction = augment(rf_fit, new_data = test_data) |&gt; \n    select(-starts_with(\"T\")) |&gt; \n    mutate(label = strain_label[[i]])\n  \n  return(prediction)\n})\n\nHRM_result = predictions |&gt; \n  bind_rows() |&gt; \n  summarise(.pred = mean(.pred), .by = c(sample, label)) |&gt; \n  mutate(species = if_else(label == 'label_E', 'eco', 'ppu'),\n         quantity = 2^.pred,\n         method = 'HRM-ML') |&gt; \n  select(sample, species, quantity, method)\n\n\nHRM_result |&gt; plot_syncom()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Method Evaluation</span>"
    ]
  },
  {
    "objectID": "method-evaluation.html#comparison",
    "href": "method-evaluation.html#comparison",
    "title": "6  Method Evaluation",
    "section": "6.6 Comparison",
    "text": "6.6 Comparison\n\nthree_result = list(qPCR_result, sequencing_result, HRM_result) |&gt; \n  bind_rows() |&gt; \n  group_by(method, sample) |&gt; \n  mutate(prop = quantity/sum(quantity)) |&gt; \n  ungroup()\n\n\np_prop = ggplot(three_result, aes(sample, prop, fill = species)) +\n  geom_col() +\n  facet_wrap(~method, ncol = 1) +\n  scale_y_continuous(labels = scales::percent) +\n  scale_x_discrete(labels = function(x) {\n    x[seq(2, length(x), 2)] &lt;- \"\" \n    x\n  }) +\n  scale_fill_manual(values = strain_color) +\n  labs(x = NULL, y = \"proportion\") +\n  theme(legend.position = \"none\")\n\np_prop\n\n\n\n\n\n\n\n\n\nlibrary(tidyr)\nec_prop = three_result |&gt; \n  filter(species == 'eco') |&gt; \n  pivot_wider(id_cols = sample, names_from = method, values_from = prop) |&gt; \n  na.omit()\n\ncor(ec_prop |&gt; select(-sample), method = \"spearman\")\n\n            qPCR       NGS    HRM-ML\nqPCR   1.0000000 0.7851782 0.7803002\nNGS    0.7851782 1.0000000 0.7166979\nHRM-ML 0.7803002 0.7166979 1.0000000\n\n\n\nec_prop_difference = ec_prop |&gt; \n  rowwise() |&gt; \n  mutate(qPCR_vs_mc = mean(abs(qPCR - `HRM-ML`)),\n         qPCR_vs_ngs = -mean(abs(qPCR - NGS))) |&gt; \n  pivot_longer(cols = starts_with('qPCR_vs'), \n               names_to = 'comparison', \n               values_to = 'abs_distance')\n\n# mean absolute differences\nec_prop_difference |&gt; summarise(average = mean(abs(abs_distance)), .by = comparison)\n\n# A tibble: 2 × 2\n  comparison  average\n  &lt;chr&gt;         &lt;dbl&gt;\n1 qPCR_vs_mc   0.0790\n2 qPCR_vs_ngs  0.144 \n\n\n\np_diff = ec_prop_difference |&gt;\n  ggplot(ggplot2::aes(sample, abs_distance, fill = comparison)) +\n  geom_col() +\n  scale_x_discrete(labels = function(x) {\n    x[seq(2, length(x), 2)] &lt;- \"\" \n    x\n  }) +\n  annotate(\"label\", x = -Inf, y = Inf, \n           label = \"HRM-ML vs qPCR\", \n           hjust = -0.1, vjust = 1.5, label.size = NA,\n           color = \"#1B9E77\") +\n  annotate(\"label\", x = -Inf, y = -Inf, \n           label = \"NGS vs qPCR\", \n           hjust = -0.1, vjust = -0.5, label.size = NA,\n           color = \"#D95F02\") +\n  labs(y = \"absolute difference\") +\n  scale_y_continuous(labels = function(x) scales::percent(abs(x))) +\n  scale_fill_manual(values = c(\"#1B9E77\", \"#D95F02\")) +\n  theme(legend.position = \"none\")\n\np_diff\n\n\n\n\n\n\n\n\n\nplot_grid(p_prop, p_diff, align = \"v\", ncol = 1, \n          rel_heights = c(2, 1), \n          labels = \"auto\")\n\n\n\n\n\n\n\nggsave(\"figures/figure5.jpg\")\n\nSaving 5.5 x 4.95 in image",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Method Evaluation</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]